// Generated by CoffeeScript 1.8.0
(function() {
  var AutoSealDelayMs, BlockSize, ReqOpenIntervalMs, ServerConn, assert, debug, dlogSock, future, http, https, log, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  https = require("https");

  http = require("http");

  log = require("lawg");

  future = require("phuture");

  assert = require("assert");

  debug = require("../debug");

  _ref = require("./Constants"), BlockSize = _ref.BlockSize, AutoSealDelayMs = _ref.AutoSealDelayMs, ReqOpenIntervalMs = _ref.ReqOpenIntervalMs;

  if (debug.isDebug) {
    dlogSock = function(msg, socket) {
      return log("[" + (socket && socket.remotePort ? socket.remotePort : '') + "]" + msg);
    };
  } else {
    dlogSock = function() {};
  }

  module.exports = ServerConn = (function(_super) {
    __extends(ServerConn, _super);

    function ServerConn(sessionId, chainedApps) {
      this.sessionId = sessionId;
      this.chainedApps = chainedApps;
      ServerConn.__super__.constructor.call(this, {});
      this._sig = "httpSvr";
      this._ts = Date.now();
      this.timeOutTimer = future.interval(ReqOpenIntervalMs, (function(_this) {
        return function() {
          if (Date.now() - _this._ts > ReqOpenIntervalMs * 2) {
            return _this.emit('error', 'Client poll timed out error');
          }
        };
      })(this));
      this._app = (function(_this) {
        return function(req, res, next) {
          var dir;
          if (_this.sessionId === req.headers['x-htunsess']) {
            req.on('error', function(err) {
              return _this.emit('error', err);
            });
            res.on('error', function(err) {
              return _this.emit('error', err);
            });
            dir = req.headers['x-htundir'];
            res.writeHead(200, {});
            res.socket.setNoDelay(true);
            if (dir === 'send') {
              req.on('data', function(d) {
                _this._ts = Date.now();
                _this.push(d);
                return dlogSock('Svr recving ' + d.length, req.socket);
              });
              return req.on('end', function() {
                return res.end();
              });
            } else {
              res._n = 0;
              res.send = function(chunk) {
                dlogSock('Svr sending ' + chunk.length, res.socket);
                res._n += chunk.length;
                if (!res._sealed) {
                  res.write(chunk);
                } else {
                  assert(false);
                }
                if (res._n >= BlockSize) {
                  return res.seal();
                } else {
                  if (res._timer) {
                    res._timer.cancel();
                  }
                  return res._timer = future.once(AutoSealDelayMs, function() {
                    return res.seal();
                  });
                }
              };
              res.seal = function() {
                if (res._sealed) {
                  return;
                }
                if (res._timer) {
                  res._timer.cancel();
                }
                res._sealed = true;
                res.end();
                _this.pushRes = void 0;
                return _this._ts = Date.now();
              };
              res._timer = future.once(ReqOpenIntervalMs, function() {
                return res.seal();
              });
              _this._ts = Date.now();
              _this.pushRes = res;
              if (_this._chunk) {
                _this.pushRes.send(_this._chunk);
                _this._chunkCb();
                return _this._chunk = _this._chunkCb = void 0;
              }
            }
          } else {
            return next();
          }
        };
      })(this);
      this.chainedApps.add(this._app);
    }

    ServerConn.prototype.end = function() {
      ServerConn.__super__.end.call(this);
      this.timeOutTimer.cancel();
      return this.chainedApps.remove(this._app);
    };

    ServerConn.prototype._read = function() {};

    ServerConn.prototype._write = function(chunk, encoding, callback) {
      if (this.pushRes) {
        this.pushRes.send(chunk);
        return callback();
      } else {
        this._chunk = chunk;
        return this._chunkCb = callback;
      }
    };

    return ServerConn;

  })(require("stream").Duplex);

}).call(this);

//# sourceMappingURL=ServerConn.js.map
